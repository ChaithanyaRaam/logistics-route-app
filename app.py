# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-Xvp9ny6pf-J5-ByQGZKRlpKEU-48EzD
"""

import streamlit as st
import pandas as pd
import math
import requests
import xml.etree.ElementTree as ET

# --------------------------------------------------
# PAGE CONFIG
# --------------------------------------------------
st.set_page_config(
    page_title="Multi-Warehouse Geo-Logical Route Optimizer",
    layout="wide"
)
st.title("ðŸšš Multi-Warehouse Route Optimization (Geo-Logical Distance)")

# --------------------------------------------------
# GEO FUNCTIONS
# --------------------------------------------------
def haversine(lat1, lon1, lat2, lon2):
    R = 6371
    dlat = math.radians(lat2 - lat1)
    dlon = math.radians(lon2 - lon1)
    a = (
        math.sin(dlat / 2) ** 2
        + math.cos(math.radians(lat1))
        * math.cos(math.radians(lat2))
        * math.sin(dlon / 2) ** 2
    )
    return 2 * R * math.asin(math.sqrt(a))


def bearing(lat1, lon1, lat2, lon2):
    return math.atan2(
        math.radians(lon2 - lon1),
        math.radians(lat2 - lat1)
    )

# --------------------------------------------------
# KML PARSER (PURE XML, CLOUD SAFE)
# --------------------------------------------------
def parse_kml_from_url(kml_url):
    response = requests.get(kml_url, timeout=30)
    response.raise_for_status()

    root = ET.fromstring(response.content)
    ns = {"kml": "http://www.opengis.net/kml/2.2"}

    rows = []

    for placemark in root.findall(".//kml:Placemark", ns):
        name = placemark.find("kml:name", ns)
        coord = placemark.find(".//kml:coordinates", ns)

        if name is None or coord is None:
            continue

        lon, lat, *_ = coord.text.strip().split(",")

        rows.append({
            "Pincode": name.text.strip(),
            "Latitude": float(lat),
            "Longitude": float(lon),
            "TotalOrders": 1
        })

    return pd.DataFrame(rows)

# --------------------------------------------------
# ROUTE BUILDERS
# --------------------------------------------------
def empty_route(plan_type):
    return pd.DataFrame(columns=[
        "Warehouse", "Biker_ID", "Pincode",
        "Latitude", "Longitude", "TotalOrders",
        "Sequence", "Plan_Type"
    ])


def build_geo_routes(df, wh_lat, wh_lon, wh_name, plan_type):
    routes = []

    for biker in sorted(df["Biker_ID"].unique()):
        group = df[df["Biker_ID"] == biker].copy()

        group["Bearing"] = group.apply(
            lambda x: bearing(wh_lat, wh_lon, x.Latitude, x.Longitude), axis=1
        )
        group["Distance"] = group.apply(
            lambda x: haversine(wh_lat, wh_lon, x.Latitude, x.Longitude), axis=1
        )

        group = group.sort_values(["Bearing", "Distance"])

        seq = 1
        routes.append({
            "Warehouse": wh_name,
            "Biker_ID": biker,
            "Pincode": wh_name,
            "Latitude": wh_lat,
            "Longitude": wh_lon,
            "TotalOrders": 0,
            "Sequence": seq,
            "Plan_Type": plan_type
        })

        for _, r in group.iterrows():
            seq += 1
            routes.append({
                "Warehouse": wh_name,
                "Biker_ID": biker,
                "Pincode": r["Pincode"],
                "Latitude": r["Latitude"],
                "Longitude": r["Longitude"],
                "TotalOrders": r["TotalOrders"],
                "Sequence": seq,
                "Plan_Type": plan_type
            })

        seq += 1
        routes.append({
            "Warehouse": wh_name,
            "Biker_ID": biker,
            "Pincode": wh_name,
            "Latitude": wh_lat,
            "Longitude": wh_lon,
            "TotalOrders": 0,
            "Sequence": seq,
            "Plan_Type": plan_type
        })

    return pd.DataFrame(routes)

# --------------------------------------------------
# PLAN A â€“ CAPACITY BASED
# --------------------------------------------------
def plan_a(df, capacity, wh_lat, wh_lon, wh_name):
    if df.empty:
        return empty_route("Plan A")

    biker = 1
    load = 0
    assigned = []

    for _, r in df.iterrows():
        if load + r["TotalOrders"] > capacity:
            biker += 1
            load = 0

        assigned.append({**r, "Biker_ID": biker})
        load += r["TotalOrders"]

    return build_geo_routes(
        pd.DataFrame(assigned),
        wh_lat, wh_lon, wh_name,
        "Plan A â€“ Capacity Based"
    )

# --------------------------------------------------
# PLAN B â€“ RIDER CONSTRAINED
# --------------------------------------------------
def plan_b(df, riders, wh_lat, wh_lon, wh_name):
    if df.empty or riders == 0:
        return empty_route("Plan B")

    assigned = []
    rider_ids = list(range(1, riders + 1))
    idx = 0

    for _, r in df.iterrows():
        assigned.append({**r, "Biker_ID": rider_ids[idx]})
        idx = (idx + 1) % riders

    return build_geo_routes(
        pd.DataFrame(assigned),
        wh_lat, wh_lon, wh_name,
        "Plan B â€“ Rider Constrained"
    )

# --------------------------------------------------
# SIDEBAR INPUTS
# --------------------------------------------------
st.sidebar.header("Service Area")

KML_URL = st.sidebar.text_input(
    "Service Area KML URL",
    "https://data.opencity.in/dataset/d71a695c-1d72-4d3e-bb33-a252a27d3a89/resource/90a62fd4-9154-4dbf-b633-e713a060c801/download/cb0beca1-23d7-4a61-8b53-927d6fb037ea.kml"
)

st.sidebar.header("Warehouse 1")
wh1_name = st.sidebar.text_input("WH1 Name", "WH_1")
wh1_lat = st.sidebar.number_input("WH1 Latitude", value=13.02, format="%.6f")
wh1_lon = st.sidebar.number_input("WH1 Longitude", value=80.22, format="%.6f")

enable_wh2 = st.sidebar.checkbox("Enable Warehouse 2", value=True)

wh2_name = "WH_2"
wh2_lat = 13.08
wh2_lon = 80.28

if enable_wh2:
    st.sidebar.header("Warehouse 2")
    wh2_name = st.sidebar.text_input("WH2 Name", "WH_2")
    wh2_lat = st.sidebar.number_input("WH2 Latitude", value=13.08, format="%.6f")
    wh2_lon = st.sidebar.number_input("WH2 Longitude", value=80.28, format="%.6f")

st.sidebar.header("Riders")
total_riders = st.sidebar.number_input("Total Riders", 1, 200, 10)
capacity_per_rider = st.sidebar.number_input("Max Orders per Rider (Plan A)", 1, 50, 10)

# --------------------------------------------------
# EXECUTION
# --------------------------------------------------
if st.button("Load & Generate Plans"):
    base = parse_kml_from_url(KML_URL)
    st.success(f"Loaded {len(base)} pincodes from KML")

    if enable_wh2:
        base["Dist_WH1"] = base.apply(
            lambda x: haversine(x.Latitude, x.Longitude, wh1_lat, wh1_lon), axis=1
        )
        base["Dist_WH2"] = base.apply(
            lambda x: haversine(x.Latitude, x.Longitude, wh2_lat, wh2_lon), axis=1
        )

        wh1_df = base[base["Dist_WH1"] <= base["Dist_WH2"]].copy()
        wh2_df = base[base["Dist_WH1"] > base["Dist_WH2"]].copy()
    else:
        wh1_df = base.copy()
        wh2_df = pd.DataFrame()

    if enable_wh2:
        total_orders = wh1_df["TotalOrders"].sum() + wh2_df["TotalOrders"].sum()
        wh1_riders = max(1, round(total_riders * wh1_df["TotalOrders"].sum() / total_orders))
        wh2_riders = total_riders - wh1_riders
    else:
        wh1_riders = total_riders
        wh2_riders = 0

    global_a = plan_a(base, capacity_per_rider, wh1_lat, wh1_lon, "GLOBAL")
    global_b = plan_b(base, total_riders, wh1_lat, wh1_lon, "GLOBAL")

    wh1_a = plan_a(wh1_df, capacity_per_rider, wh1_lat, wh1_lon, wh1_name)
    wh1_b = plan_b(wh1_df, wh1_riders, wh1_lat, wh1_lon, wh1_name)

    wh2_a = plan_a(wh2_df, capacity_per_rider, wh2_lat, wh2_lon, wh2_name)
    wh2_b = plan_b(wh2_df, wh2_riders, wh2_lat, wh2_lon, wh2_name)

    st.subheader("â¬‡ Download Route Plans")

    st.download_button("â¬‡ Plan A â€“ Global", global_a.to_csv(index=False), "Plan_A_Global.csv")
    st.download_button("â¬‡ Plan B â€“ Global", global_b.to_csv(index=False), "Plan_B_Global.csv")
    st.download_button("â¬‡ Plan A â€“ WH1", wh1_a.to_csv(index=False), "WH1_Plan_A.csv")
    st.download_button("â¬‡ Plan B â€“ WH1", wh1_b.to_csv(index=False), "WH1_Plan_B.csv")
    st.download_button("â¬‡ Plan A â€“ WH2", wh2_a.to_csv(index=False), "WH2_Plan_A.csv")
    st.download_button("â¬‡ Plan B â€“ WH2", wh2_b.to_csv(index=False), "WH2_Plan_B.csv")

    st.subheader("ðŸš¦ Rider Allocation Summary")

    summary = pd.DataFrame([
        {"Warehouse": wh1_name, "Orders": wh1_df["TotalOrders"].sum(), "Riders": wh1_riders},
        {"Warehouse": wh2_name if enable_wh2 else "-",
         "Orders": wh2_df["TotalOrders"].sum() if enable_wh2 else 0,
         "Riders": wh2_riders}
    ])

    summary["Orders per Rider"] = (summary["Orders"] / summary["Riders"]).round(2)
    st.dataframe(summary)

