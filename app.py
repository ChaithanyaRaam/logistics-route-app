# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-Xvp9ny6pf-J5-ByQGZKRlpKEU-48EzD
"""

import streamlit as st
import pandas as pd
import math
import requests
import xml.etree.ElementTree as ET

# ==================================================
# SESSION STATE
# ==================================================
if "plans_generated" not in st.session_state:
    st.session_state.plans_generated = False

# ==================================================
# PAGE CONFIG
# ==================================================
st.set_page_config(
    page_title="Zone-Aware Multi-Warehouse Route Optimizer",
    layout="wide"
)
st.title("ðŸšš Zone-Aware Multi-Warehouse Route Optimization")

# ==================================================
# GEO HELPERS
# ==================================================
def haversine(lat1, lon1, lat2, lon2):
    R = 6371
    dlat = math.radians(lat2 - lat1)
    dlon = math.radians(lon2 - lon1)
    a = (
        math.sin(dlat / 2) ** 2
        + math.cos(math.radians(lat1))
        * math.cos(math.radians(lat2))
        * math.sin(dlon / 2) ** 2
    )
    return 2 * R * math.asin(math.sqrt(a))


def bearing(lat1, lon1, lat2, lon2):
    return math.atan2(
        math.radians(lon2 - lon1),
        math.radians(lat2 - lat1)
    )

# ==================================================
# ZONE LOGIC (CHENNAI-OPTIMIZED)
# ==================================================
def assign_zone(lat, lon, wh_lat):
    """
    Simple, explainable zoning relative to warehouse latitude.
    Tuned for Chennai (Saidapet-like centroid).
    """
    if lat < wh_lat - 0.03:
        return "SOUTH_SE"
    elif lat < wh_lat + 0.02:
        return "CENTRAL_WEST"
    else:
        return "NORTH_WEST"


ZONE_ORDER = [
    "SOUTH_SE",
    "CENTRAL_WEST",
    "NORTH_WEST"
]

# ==================================================
# KML PARSER (CLOUD SAFE)
# ==================================================
def parse_kml_from_url(kml_url):
    headers = {"User-Agent": "Mozilla/5.0"}
    r = requests.get(kml_url, headers=headers, timeout=30)
    if r.status_code != 200:
        raise ValueError("Failed to download KML")

    root = ET.fromstring(r.content)
    ns = {"kml": "http://www.opengis.net/kml/2.2"}

    rows = []
    for pm in root.findall(".//kml:Placemark", ns):
        name = pm.find("kml:name", ns)
        coord = pm.find(".//kml:coordinates", ns)
        if name is None or coord is None:
            continue

        lon, lat, *_ = coord.text.strip().split(",")
        rows.append({
            "Pincode": str(name.text).strip(),
            "Latitude": float(lat),
            "Longitude": float(lon)
        })

    if not rows:
        raise ValueError("No pincodes found in KML")

    return pd.DataFrame(rows)

# ==================================================
# ROUTE BUILDERS (ZONE AWARE)
# ==================================================
def empty_route(plan_type):
    return pd.DataFrame(columns=[
        "Warehouse", "Biker_ID", "Pincode",
        "Latitude", "Longitude", "TotalOrders",
        "Sequence", "Plan_Type"
    ])


def build_geo_routes_zone_aware(df, wh_lat, wh_lon, wh_name, plan_type):
    routes = []

    for biker in sorted(df["Biker_ID"].unique()):
        grp = df[df["Biker_ID"] == biker].copy()

        # Assign zones
        grp["Zone"] = grp.apply(
            lambda x: assign_zone(x.Latitude, x.Longitude, wh_lat),
            axis=1
        )

        # Bearing & distance
        grp["Bearing"] = grp.apply(
            lambda x: (math.degrees(
                bearing(wh_lat, wh_lon, x.Latitude, x.Longitude)
            ) + 360) % 360,
            axis=1
        )

        grp["Distance"] = grp.apply(
            lambda x: haversine(wh_lat, wh_lon, x.Latitude, x.Longitude),
            axis=1
        )

        ordered = []

        # Zone-by-zone sweep
        for zone in ZONE_ORDER:
            zg = grp[grp["Zone"] == zone]
            if zg.empty:
                continue
            zg = zg.sort_values(["Bearing", "Distance"])
            ordered.append(zg)

        if not ordered:
            continue

        final_grp = pd.concat(ordered)

        # Build route
        seq = 1
        routes.append({
            "Warehouse": wh_name,
            "Biker_ID": biker,
            "Pincode": wh_name,
            "Latitude": wh_lat,
            "Longitude": wh_lon,
            "TotalOrders": 0,
            "Sequence": seq,
            "Plan_Type": plan_type
        })

        for _, r in final_grp.iterrows():
            seq += 1
            routes.append({
                "Warehouse": wh_name,
                "Biker_ID": biker,
                "Pincode": r["Pincode"],
                "Latitude": r["Latitude"],
                "Longitude": r["Longitude"],
                "TotalOrders": r["TotalOrders"],
                "Sequence": seq,
                "Plan_Type": plan_type
            })

    return pd.DataFrame(routes)

# ==================================================
# PLAN A â€“ CAPACITY BASED
# ==================================================
def plan_a(df, capacity, wh_lat, wh_lon, wh_name):
    if df.empty:
        return empty_route("Plan A")

    assigned, biker, load = [], 1, 0
    for _, r in df.iterrows():
        if load + r["TotalOrders"] > capacity:
            biker += 1
            load = 0
        assigned.append({**r, "Biker_ID": biker})
        load += r["TotalOrders"]

    return build_geo_routes_zone_aware(
        pd.DataFrame(assigned),
        wh_lat, wh_lon, wh_name,
        "Plan A â€“ Capacity Based"
    )

# ==================================================
# PLAN B â€“ RIDER CONSTRAINED (ZONE AWARE)
# ==================================================
def plan_b(df, riders, wh_lat, wh_lon, wh_name):
    if df.empty or riders == 0:
        return empty_route("Plan B")

    df = df.copy()

    # Global sweep for rider assignment
    df["Bearing"] = df.apply(
        lambda x: (math.degrees(
            bearing(wh_lat, wh_lon, x.Latitude, x.Longitude)
        ) + 360) % 360,
        axis=1
    )

    df = df.sort_values("Bearing").reset_index(drop=True)

    chunk_size = math.ceil(len(df) / riders)
    assigned = []

    for i in range(riders):
        chunk = df.iloc[i * chunk_size:(i + 1) * chunk_size]
        for _, r in chunk.iterrows():
            assigned.append({**r, "Biker_ID": i + 1})

    assigned_df = pd.DataFrame(assigned)

    return build_geo_routes_zone_aware(
        assigned_df,
        wh_lat, wh_lon, wh_name,
        "Plan B â€“ Rider Constrained (Zone Aware)"
    )

# ==================================================
# SIDEBAR INPUTS
# ==================================================
st.sidebar.header("Service Area")
KML_URL = st.sidebar.text_input(
    "Service Area KML URL",
    "https://data.opencity.in/dataset/d71a695c-1d72-4d3e-bb33-a252a27d3a89/resource/90a62fd4-9154-4dbf-b633-e713a060c801/download/cb0beca1-23d7-4a61-8b53-927d6fb037ea.kml"
)

uploaded_file = st.sidebar.file_uploader(
    "Upload Pincode Orders (CSV / Excel)",
    type=["csv", "xlsx"]
)

st.sidebar.header("Warehouse")
wh_lat = st.sidebar.number_input("Warehouse Latitude", value=13.02)
wh_lon = st.sidebar.number_input("Warehouse Longitude", value=80.22)

st.sidebar.header("Riders")
capacity_per_rider = st.sidebar.number_input("Capacity per Rider (Plan A)", 1, 50, 10)
total_riders = st.sidebar.number_input("Total Riders (Plan B)", 1, 200, 10)

# ==================================================
# GENERATE PLANS
# ==================================================
if st.button("Load & Generate Plans"):
    try:
        base = parse_kml_from_url(KML_URL)
        base["Pincode"] = base["Pincode"].astype(str)

        if uploaded_file:
            orders_df = (
                pd.read_csv(uploaded_file)
                if uploaded_file.name.endswith(".csv")
                else pd.read_excel(uploaded_file)
            )

            orders_df["Pincode"] = orders_df["Pincode"].astype(str)
            orders_df["Orders"] = pd.to_numeric(
                orders_df["Orders"], errors="coerce"
            ).fillna(0).astype(int)

            orders_df = orders_df.groupby("Pincode", as_index=False)["Orders"].sum()
            base = base.merge(orders_df, on="Pincode", how="left")
            base["TotalOrders"] = base["Orders"].fillna(0).astype(int)
        else:
            base["TotalOrders"] = 1

        base = base[base["TotalOrders"] > 0]

        st.session_state.plan_a = plan_a(base, capacity_per_rider, wh_lat, wh_lon, "WH")
        st.session_state.plan_b = plan_b(base, total_riders, wh_lat, wh_lon, "WH")

        st.session_state.plans_generated = True
        st.success("Zone-aware plans generated successfully")

    except Exception as e:
        st.error("Error generating plans")
        st.exception(e)

# ==================================================
# DOWNLOADS
# ==================================================
if st.session_state.plans_generated:
    st.subheader("â¬‡ Download Route Plans")

    st.download_button(
        "Plan A â€“ Capacity Based",
        st.session_state.plan_a.to_csv(index=False),
        "Plan_A_ZoneAware.csv"
    )

    st.download_button(
        "Plan B â€“ Rider Constrained (Zone Aware)",
        st.session_state.plan_b.to_csv(index=False),
        "Plan_B_ZoneAware.csv"
    )

