# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-Xvp9ny6pf-J5-ByQGZKRlpKEU-48EzD
"""

import streamlit as st
import pandas as pd
import math
import xml.etree.ElementTree as ET
import folium
from streamlit_folium import st_folium

# ==================================================
# SESSION STATE
# ==================================================
if "routes_generated" not in st.session_state:
    st.session_state.routes_generated = False

# ==================================================
# APP CONFIG
# ==================================================
st.set_page_config(page_title="Route Optimizer", layout="wide")
st.title("ðŸšš Multi-Warehouse Route Optimizer (Stage-Safe)")

# ==================================================
# LOCKED WAREHOUSES (DO NOT EDIT)
# ==================================================
WH1_NAME = "WH1"
WH2_NAME = "WH2"

WH1_LAT, WH1_LON = 13.02, 80.22     # Chitlapakkam
WH2_LAT, WH2_LON = 13.08, 80.28     # Guindy

KML_PATH = "data/chennai_pincodes.kml"

# ==================================================
# GEO HELPERS
# ==================================================
def haversine(lat1, lon1, lat2, lon2):
    R = 6371
    dlat = math.radians(lat2 - lat1)
    dlon = math.radians(lon2 - lon1)
    a = (
        math.sin(dlat / 2) ** 2 +
        math.cos(math.radians(lat1)) *
        math.cos(math.radians(lat2)) *
        math.sin(dlon / 2) ** 2
    )
    return 2 * R * math.asin(math.sqrt(a))

# ==================================================
# STAGE RULES
# ==================================================
def wh1_stage(d):
    if d <= 7: return 1
    elif d <= 18: return 2
    else: return 3

def wh2_stage(d):
    if d <= 6: return 1
    elif d <= 12: return 2
    elif d <= 20: return 3
    else: return 4

# ==================================================
# KML LOADER
# ==================================================
def parse_kml(path):
    root = ET.parse(path).getroot()
    ns = {"kml": "http://www.opengis.net/kml/2.2"}
    rows = []

    for pm in root.findall(".//kml:Placemark", ns):
        name = pm.find("kml:name", ns)
        coord = pm.find(".//kml:coordinates", ns)
        if not name or not coord:
            continue
        lon, lat, *_ = coord.text.strip().split(",")
        rows.append({
            "Pincode": name.text.strip(),
            "Latitude": float(lat),
            "Longitude": float(lon)
        })
    return pd.DataFrame(rows)

# ==================================================
# ZIG-ZAG CHECK
# ==================================================
def has_zigzag(stages):
    return stages != sorted(stages)

# ==================================================
# ROUTE BUILDER (AUTO-FIX)
# ==================================================
def build_routes(df, wh_lat, wh_lon, wh_name, plan, max_attempts=3):
    results = []

    for biker in sorted(df.Biker_ID.unique()):
        sub = df[df.Biker_ID == biker].copy()

        sub["Distance"] = sub.apply(
            lambda x: haversine(wh_lat, wh_lon, x.Latitude, x.Longitude),
            axis=1
        )

        sub["Stage"] = sub["Distance"].apply(
            wh1_stage if wh_name == WH1_NAME else wh2_stage
        )

        # retry logic if zig-zag
        for _ in range(max_attempts):
            sub = sub.sort_values(["Stage", "Distance"])
            if not has_zigzag(sub.Stage.tolist()):
                break

        seq = 1
        results.append({
            "Warehouse": wh_name,
            "Biker_ID": biker,
            "Pincode": wh_name,
            "Latitude": wh_lat,
            "Longitude": wh_lon,
            "Stage": 0,
            "Sequence": seq,
            "Plan": plan
        })

        for _, r in sub.iterrows():
            seq += 1
            results.append({
                "Warehouse": wh_name,
                "Biker_ID": biker,
                "Pincode": r.Pincode,
                "Latitude": r.Latitude,
                "Longitude": r.Longitude,
                "Stage": r.Stage,
                "Sequence": seq,
                "Plan": plan
            })

    return pd.DataFrame(results)

# ==================================================
# MAP
# ==================================================
def plot_route(df):
    df = df.sort_values("Sequence")
    m = folium.Map(
        location=[df.iloc[0].Latitude, df.iloc[0].Longitude],
        zoom_start=12,
        tiles="cartodbpositron"
    )

    coords = []
    for _, r in df.iterrows():
        coords.append([r.Latitude, r.Longitude])
        folium.Marker(
            [r.Latitude, r.Longitude],
            popup=f"{r.Sequence} | {r.Pincode} | Stage {r.Stage}"
        ).add_to(m)

    folium.PolyLine(coords, weight=4).add_to(m)
    return m

# ==================================================
# INPUT
# ==================================================
uploaded = st.sidebar.file_uploader(
    "Upload Orders (Pincode, Orders)",
    type=["csv", "xlsx"]
)

# ==================================================
# GENERATE
# ==================================================
if st.button("Generate Routes") and uploaded is not None:
    base = parse_kml(KML_PATH)

    orders = (
        pd.read_csv(uploaded)
        if uploaded.name.endswith(".csv")
        else pd.read_excel(uploaded)
    )

    orders["Pincode"] = orders["Pincode"].astype(str)
    orders["Orders"] = orders["Orders"].astype(int)

    base = base.merge(orders, on="Pincode", how="inner")

    base["D1"] = base.apply(lambda x: haversine(x.Latitude, x.Longitude, WH1_LAT, WH1_LON), axis=1)
    base["D2"] = base.apply(lambda x: haversine(x.Latitude, x.Longitude, WH2_LAT, WH2_LON), axis=1)

    wh1 = base[base.D1 <= base.D2].copy()
    wh2 = base[base.D1 > base.D2].copy()

    wh1["Biker_ID"] = 1
    wh2["Biker_ID"] = 1

    st.session_state.wh1 = build_routes(wh1, WH1_LAT, WH1_LON, WH1_NAME, "Plan B")
    st.session_state.wh2 = build_routes(wh2, WH2_LAT, WH2_LON, WH2_NAME, "Plan B")

    st.session_state.routes_generated = True

# ==================================================
# DISPLAY (TABS â€“ NO SCROLL)
# ==================================================
if st.session_state.routes_generated:

    st.subheader("ðŸ›µ WH1 Routes")
    tabs = st.tabs([f"Biker {i}" for i in st.session_state.wh1.Biker_ID.unique()])

    for tab, biker in zip(tabs, st.session_state.wh1.Biker_ID.unique()):
        with tab:
            df = st.session_state.wh1[st.session_state.wh1.Biker_ID == biker]
            st.dataframe(df)
            st_folium(plot_route(df), height=450)

    st.subheader("ðŸ›µ WH2 Routes")
    tabs = st.tabs([f"Biker {i}" for i in st.session_state.wh2.Biker_ID.unique()])

    for tab, biker in zip(tabs, st.session_state.wh2.Biker_ID.unique()):
        with tab:
            df = st.session_state.wh2[st.session_state.wh2.Biker_ID == biker]
            st.dataframe(df)
            st_folium(plot_route(df), height=450)

