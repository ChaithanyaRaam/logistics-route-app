# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-Xvp9ny6pf-J5-ByQGZKRlpKEU-48EzD
"""

import streamlit as st
import pandas as pd
import math
import xml.etree.ElementTree as ET
import folium
from streamlit_folium import st_folium

# ==================================================
# SESSION STATE
# ==================================================
if "routes_generated" not in st.session_state:
    st.session_state.routes_generated = False

# ==================================================
# APP CONFIG
# ==================================================
st.set_page_config(
    page_title="Multi-Warehouse Route Optimizer (Stage-Safe)",
    layout="wide"
)
st.title("ðŸšš Multi-Warehouse Route Optimizer (Stage-Safe, Capacity-Aware)")

# ==================================================
# LOCKED WAREHOUSES (DO NOT EXPOSE TO UI)
# ==================================================
WH1_NAME = "WH1"   # Chitlapakkam
WH2_NAME = "WH2"   # Guindy

WH1_LAT, WH1_LON = 13.02, 80.22
WH2_LAT, WH2_LON = 13.08, 80.28

KML_PATH = "data/chennai_pincodes.kml"

# ==================================================
# GEO HELPERS
# ==================================================
def haversine(lat1, lon1, lat2, lon2):
    R = 6371
    dlat = math.radians(lat2 - lat1)
    dlon = math.radians(lon2 - lon1)
    a = (
        math.sin(dlat / 2) ** 2 +
        math.cos(math.radians(lat1)) *
        math.cos(math.radians(lat2)) *
        math.sin(dlon / 2) ** 2
    )
    return 2 * R * math.asin(math.sqrt(a))

# ==================================================
# STAGE LOGIC
# ==================================================
def wh1_stage(d):
    if d <= 7: return 1
    elif d <= 18: return 2
    else: return 3

def wh2_stage(d):
    if d <= 6: return 1
    elif d <= 12: return 2
    elif d <= 20: return 3
    else: return 4

# ==================================================
# KML LOADER
# ==================================================
def parse_kml(path):
    root = ET.parse(path).getroot()
    ns = {"kml": "http://www.opengis.net/kml/2.2"}
    rows = []

    for pm in root.findall(".//kml:Placemark", ns):
        name = pm.find("kml:name", ns)
        coord = pm.find(".//kml:coordinates", ns)
        if not name or not coord:
            continue
        lon, lat, *_ = coord.text.strip().split(",")
        rows.append({
            "Pincode": name.text.strip(),
            "Latitude": float(lat),
            "Longitude": float(lon)
        })

    return pd.DataFrame(rows)

# ==================================================
# AUTO-RELAX MIN CAPACITY LOGIC
# ==================================================
def assign_bikers_with_auto_relax(df, min_cap, max_cap, max_bikers):
    """
    Stage-safe capacity assignment.
    Auto-relaxes min capacity ONLY for the last biker if demand is uneven.
    """
    df = df.copy()

    biker_id = 1
    load = 0
    biker_ids = []
    loads = []

    for _, r in df.iterrows():
        if load + r.Orders > max_cap:
            loads.append(load)
            biker_id += 1
            load = 0

        biker_ids.append(biker_id)
        load += r.Orders

        if biker_id > max_bikers:
            raise ValueError("Biker limit exceeded")

    loads.append(load)
    df["Biker_ID"] = biker_ids

    # Auto-relax only last biker
    for i, l in enumerate(loads):
        if l < min_cap and i != len(loads) - 1:
            raise ValueError(
                f"Biker {i+1} load {l} below minimum capacity {min_cap}"
            )

    return df

# ==================================================
# ROUTE BUILDER (STAGE â†’ DISTANCE)
# ==================================================
def build_routes(df, wh_lat, wh_lon, wh_name):
    results = []

    for biker in sorted(df.Biker_ID.unique()):
        sub = df[df.Biker_ID == biker].copy()

        sub["Distance"] = sub.apply(
            lambda x: haversine(wh_lat, wh_lon, x.Latitude, x.Longitude),
            axis=1
        )

        sub["Stage"] = sub["Distance"].apply(
            wh1_stage if wh_name == WH1_NAME else wh2_stage
        )

        sub = sub.sort_values(["Stage", "Distance"])

        seq = 1
        results.append({
            "Warehouse": wh_name,
            "Biker_ID": biker,
            "Pincode": wh_name,
            "Latitude": wh_lat,
            "Longitude": wh_lon,
            "Stage": 0,
            "Sequence": seq
        })

        for _, r in sub.iterrows():
            seq += 1
            results.append({
                "Warehouse": wh_name,
                "Biker_ID": biker,
                "Pincode": r.Pincode,
                "Latitude": r.Latitude,
                "Longitude": r.Longitude,
                "Stage": r.Stage,
                "Sequence": seq
            })

    return pd.DataFrame(results)

# ==================================================
# MAP
# ==================================================
def plot_route(df):
    df = df.sort_values("Sequence")
    m = folium.Map(
        location=[df.iloc[0].Latitude, df.iloc[0].Longitude],
        zoom_start=12,
        tiles="cartodbpositron"
    )

    coords = []
    for _, r in df.iterrows():
        coords.append([r.Latitude, r.Longitude])
        folium.Marker(
            [r.Latitude, r.Longitude],
            popup=f"{r.Sequence} | {r.Pincode} | Stage {r.Stage}"
        ).add_to(m)

    folium.PolyLine(coords, weight=4).add_to(m)
    return m

# ==================================================
# SIDEBAR INPUTS
# ==================================================
st.sidebar.header("Capacity & Availability")

min_capacity = st.sidebar.number_input(
    "Minimum orders per biker",
    min_value=1,
    max_value=200,
    value=10
)

max_capacity = st.sidebar.number_input(
    "Maximum orders per biker",
    min_value=min_capacity,
    max_value=300,
    value=25
)

total_bikers = st.sidebar.number_input(
    "Total bikers available (WH1 + WH2)",
    min_value=1,
    max_value=500,
    value=10
)

uploaded = st.sidebar.file_uploader(
    "Upload Orders (Pincode, Orders)",
    type=["csv", "xlsx"]
)

# ==================================================
# GENERATE ROUTES
# ==================================================
if st.button("Generate Routes") and uploaded is not None:

    base = parse_kml(KML_PATH)

    orders = (
        pd.read_csv(uploaded)
        if uploaded.name.endswith(".csv")
        else pd.read_excel(uploaded)
    )

    # Normalize columns
    orders.columns = orders.columns.str.strip().str.lower()
    orders = orders.rename(columns={"pincode": "Pincode", "orders": "Orders"})

    if "Pincode" not in orders.columns or "Orders" not in orders.columns:
        st.error("Orders file must contain Pincode and Orders columns")
        st.stop()

    orders["Pincode"] = orders["Pincode"].astype(str)
    orders["Orders"] = orders["Orders"].astype(int)

    base = base.merge(orders, on="Pincode", how="inner")

    # Warehouse split
    base["D1"] = base.apply(lambda x: haversine(x.Latitude, x.Longitude, WH1_LAT, WH1_LON), axis=1)
    base["D2"] = base.apply(lambda x: haversine(x.Latitude, x.Longitude, WH2_LAT, WH2_LON), axis=1)

    wh1 = base[base.D1 <= base.D2].copy()
    wh2 = base[base.D1 > base.D2].copy()

    # Required bikers
    wh1_req = math.ceil(wh1.Orders.sum() / max_capacity) if not wh1.empty else 0
    wh2_req = math.ceil(wh2.Orders.sum() / max_capacity) if not wh2.empty else 0

    if wh1_req + wh2_req > total_bikers:
        st.error("Insufficient bikers for given demand and max capacity")
        st.stop()

    # Assign bikers
    wh1["Distance"] = wh1.apply(lambda x: haversine(x.Latitude, x.Longitude, WH1_LAT, WH1_LON), axis=1)
    wh1["Stage"] = wh1["Distance"].apply(wh1_stage)
    wh1 = wh1.sort_values(["Stage", "Distance"])

    wh1 = assign_bikers_with_auto_relax(
        wh1, min_capacity, max_capacity, wh1_req
    )

    wh2["Distance"] = wh2.apply(lambda x: haversine(x.Latitude, x.Longitude, WH2_LAT, WH2_LON), axis=1)
    wh2["Stage"] = wh2["Distance"].apply(wh2_stage)
    wh2 = wh2.sort_values(["Stage", "Distance"])

    wh2 = assign_bikers_with_auto_relax(
        wh2, min_capacity, max_capacity, wh2_req
    )

    st.session_state.wh1_routes = build_routes(wh1, WH1_LAT, WH1_LON, WH1_NAME)
    st.session_state.wh2_routes = build_routes(wh2, WH2_LAT, WH2_LON, WH2_NAME)

    st.session_state.routes_generated = True

# ==================================================
# DISPLAY (TABS â€“ NO SCROLL)
# ==================================================
if st.session_state.routes_generated:

    st.subheader("ðŸ›µ WH1 Routes")
    wh1_tabs = st.tabs(
        [f"Biker {i}" for i in sorted(st.session_state.wh1_routes.Biker_ID.unique())]
    )

    for tab, biker in zip(wh1_tabs, sorted(st.session_state.wh1_routes.Biker_ID.unique())):
        with tab:
            df = st.session_state.wh1_routes[
                st.session_state.wh1_routes.Biker_ID == biker
            ]
            st.dataframe(df)
            st_folium(plot_route(df), height=450)

    st.subheader("ðŸ›µ WH2 Routes")
    wh2_tabs = st.tabs(
        [f"Biker {i}" for i in sorted(st.session_state.wh2_routes.Biker_ID.unique())]
    )

    for tab, biker in zip(wh2_tabs, sorted(st.session_state.wh2_routes.Biker_ID.unique())):
        with tab:
            df = st.session_state.wh2_routes[
                st.session_state.wh2_routes.Biker_ID == biker
            ]
            st.dataframe(df)
            st_folium(plot_route(df), height=450)

