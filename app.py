# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-Xvp9ny6pf-J5-ByQGZKRlpKEU-48EzD
"""

import streamlit as st
import pandas as pd
import math
import xml.etree.ElementTree as ET
import folium
from streamlit_folium import st_folium

# ==================================================
# APP CONFIG
# ==================================================
st.set_page_config(
    page_title="Multi-Warehouse Route Optimizer (Stage-Based + Visual)",
    layout="wide"
)
st.title("üöö Multi-Warehouse Route Optimization (Stage-Based, Rider Friendly)")

# ==================================================
# CONSTANTS
# ==================================================
KML_PATH = "data/chennai_pincodes.kml"

WH1_NAME = "WH1"   # Chitlapakkam
WH2_NAME = "WH2"   # Guindy (SIDCO)

# ==================================================
# GEO HELPERS
# ==================================================
def haversine(lat1, lon1, lat2, lon2):
    R = 6371
    dlat = math.radians(lat2 - lat1)
    dlon = math.radians(lon2 - lon1)
    a = (
        math.sin(dlat / 2) ** 2
        + math.cos(math.radians(lat1))
        * math.cos(math.radians(lat2))
        * math.sin(dlon / 2) ** 2
    )
    return 2 * R * math.asin(math.sqrt(a))


def bearing(lat1, lon1, lat2, lon2):
    return math.atan2(
        math.radians(lon2 - lon1),
        math.radians(lat2 - lat1)
    )

# ==================================================
# STAGE LOGIC (CORE)
# ==================================================
def wh1_stage(distance_km):
    # Chitlapakkam
    if distance_km <= 7:
        return 1   # Inner Tambaram / Pallavaram
    elif distance_km <= 18:
        return 2   # OMR belt
    else:
        return 3   # Peripheral


def wh2_stage(distance_km):
    # Guindy
    if distance_km <= 6:
        return 1   # Guindy / Saidapet / Adyar
    elif distance_km <= 12:
        return 2   # Central Chennai
    elif distance_km <= 20:
        return 3   # West / Inner West
    else:
        return 4   # North Chennai

# ==================================================
# KML LOADER (LOCAL, BACKEND ONLY)
# ==================================================
def parse_kml_local(path):
    with open(path, "rb") as f:
        root = ET.fromstring(f.read())

    ns = {"kml": "http://www.opengis.net/kml/2.2"}
    rows = []

    for pm in root.findall(".//kml:Placemark", ns):
        name = pm.find("kml:name", ns)
        coord = pm.find(".//kml:coordinates", ns)

        if name is None or coord is None:
            continue

        lon, lat, *_ = coord.text.strip().split(",")

        rows.append({
            "Pincode": str(name.text).strip(),
            "Latitude": float(lat),
            "Longitude": float(lon)
        })

    if not rows:
        raise RuntimeError("KML loaded but no pincodes found")

    return pd.DataFrame(rows)

# ==================================================
# ROUTING ENGINE (STAGE ‚Üí DISTANCE ‚Üí BEARING)
# ==================================================
def build_geo_routes(df, wh_lat, wh_lon, wh_name, plan_type):

    routes = []

    for biker_id in sorted(df["Biker_ID"].unique()):
        grp = df[df["Biker_ID"] == biker_id].copy()

        grp["Distance"] = grp.apply(
            lambda x: haversine(wh_lat, wh_lon, x.Latitude, x.Longitude),
            axis=1
        )

        grp["Bearing"] = grp.apply(
            lambda x: (math.degrees(
                bearing(wh_lat, wh_lon, x.Latitude, x.Longitude)
            ) + 360) % 360,
            axis=1
        )

        if wh_name == WH1_NAME:
            grp["Stage"] = grp["Distance"].apply(wh1_stage)
        else:
            grp["Stage"] = grp["Distance"].apply(wh2_stage)

        final_df = grp.sort_values(
            ["Stage", "Distance", "Bearing"]
        )

        seq = 1
        routes.append({
            "Warehouse": wh_name,
            "Biker_ID": biker_id,
            "Pincode": wh_name,
            "Latitude": wh_lat,
            "Longitude": wh_lon,
            "TotalOrders": 0,
            "Stage": 0,
            "Sequence": seq,
            "Plan_Type": plan_type
        })

        for _, r in final_df.iterrows():
            seq += 1
            routes.append({
                "Warehouse": wh_name,
                "Biker_ID": biker_id,
                "Pincode": r.Pincode,
                "Latitude": r.Latitude,
                "Longitude": r.Longitude,
                "TotalOrders": r.TotalOrders,
                "Stage": r.Stage,
                "Sequence": seq,
                "Plan_Type": plan_type
            })

    return pd.DataFrame(routes)

# ==================================================
# PLAN A ‚Äì CAPACITY BASED (FIXED)
# ==================================================
def plan_a(df, capacity, wh_lat, wh_lon, wh_name):
    if df.empty:
        return pd.DataFrame()

    df = df.copy()
    df["Distance"] = df.apply(
        lambda x: haversine(wh_lat, wh_lon, x.Latitude, x.Longitude),
        axis=1
    )

    if wh_name == WH1_NAME:
        df["Stage"] = df["Distance"].apply(wh1_stage)
    else:
        df["Stage"] = df["Distance"].apply(wh2_stage)

    df = df.sort_values(["Stage", "Distance"])

    assigned = []
    biker = 1
    load = 0

    for _, r in df.iterrows():
        if load + r.TotalOrders > capacity:
            biker += 1
            load = 0
        assigned.append({**r, "Biker_ID": biker})
        load += r.TotalOrders

    return build_geo_routes(
        pd.DataFrame(assigned),
        wh_lat, wh_lon, wh_name,
        "Plan A ‚Äì Capacity Based"
    )

# ==================================================
# PLAN B ‚Äì RIDER COUNT BASED (FIXED)
# ==================================================
def plan_b(df, riders, wh_lat, wh_lon, wh_name):
    if riders <= 0 or df.empty:
        return pd.DataFrame()

    df = df.copy()
    df["Distance"] = df.apply(
        lambda x: haversine(wh_lat, wh_lon, x.Latitude, x.Longitude),
        axis=1
    )

    if wh_name == WH1_NAME:
        df["Stage"] = df["Distance"].apply(wh1_stage)
    else:
        df["Stage"] = df["Distance"].apply(wh2_stage)

    df = df.sort_values(["Stage", "Distance"])

    chunk = math.ceil(len(df) / riders)
    assigned = []

    for i in range(riders):
        sub = df.iloc[i * chunk:(i + 1) * chunk]
        for _, r in sub.iterrows():
            assigned.append({**r, "Biker_ID": i + 1})

    return build_geo_routes(
        pd.DataFrame(assigned),
        wh_lat, wh_lon, wh_name,
        "Plan B ‚Äì Rider Based"
    )

# ==================================================
# ROUTE VISUAL VALIDATION
# ==================================================
def plot_biker_route(route_df, wh_name):
    route_df = route_df.sort_values("Sequence")

    start = route_df.iloc[0]
    m = folium.Map(
        location=[start.Latitude, start.Longitude],
        zoom_start=12,
        tiles="cartodbpositron"
    )

    coords = []

    for _, r in route_df.iterrows():
        coords.append([r.Latitude, r.Longitude])

        if r.Pincode == wh_name:
            folium.Marker(
                [r.Latitude, r.Longitude],
                popup="Warehouse",
                icon=folium.Icon(color="black", icon="home")
            ).add_to(m)
        else:
            folium.Marker(
                [r.Latitude, r.Longitude],
                popup=f"Seq {r.Sequence} | {r.Pincode} | Stage {r.Stage}",
                icon=folium.Icon(color="blue", icon="info-sign")
            ).add_to(m)

    folium.PolyLine(coords, weight=4, opacity=0.8).add_to(m)
    return m

# ==================================================
# SIDEBAR INPUTS
# ==================================================
st.sidebar.header("Warehouses")

st.sidebar.subheader("WH1 ‚Äì Chitlapakkam")
wh1_lat = st.sidebar.number_input("WH1 Latitude", value=13.02)
wh1_lon = st.sidebar.number_input("WH1 Longitude", value=80.22)

enable_wh2 = st.sidebar.checkbox("Enable WH2", value=True)

if enable_wh2:
    st.sidebar.subheader("WH2 ‚Äì SIDCO Guindy")
    wh2_lat = st.sidebar.number_input("WH2 Latitude", value=13.08)
    wh2_lon = st.sidebar.number_input("WH2 Longitude", value=80.28)

st.sidebar.header("Riders")
capacity_per_rider = st.sidebar.number_input("Capacity per Rider", 1, 50, 10)
total_riders = st.sidebar.number_input("Total Riders", 1, 200, 10)

uploaded_file = st.sidebar.file_uploader(
    "Upload Orders File (Pincode | Orders | Zone)",
    type=["csv", "xlsx"]
)

# ==================================================
# GENERATE ROUTES
# ==================================================
if st.button("Generate Routes"):

    if uploaded_file is None:
        st.error("Please upload orders file")
        st.stop()

    base = parse_kml_local(KML_PATH)

    orders = (
        pd.read_csv(uploaded_file)
        if uploaded_file.name.endswith(".csv")
        else pd.read_excel(uploaded_file)
    )

    orders["Pincode"] = orders["Pincode"].astype(str)
    orders["Orders"] = pd.to_numeric(orders["Orders"], errors="coerce").fillna(0).astype(int)
    orders["Zone"] = orders["Zone"].astype(str)

    orders = orders.groupby(["Pincode", "Zone"], as_index=False)["Orders"].sum()

    base = base.merge(orders, on="Pincode", how="left")
    base["TotalOrders"] = base["Orders"].fillna(0).astype(int)
    base = base[base["TotalOrders"] > 0]

    if enable_wh2:
        base["D1"] = base.apply(lambda x: haversine(x.Latitude, x.Longitude, wh1_lat, wh1_lon), axis=1)
        base["D2"] = base.apply(lambda x: haversine(x.Latitude, x.Longitude, wh2_lat, wh2_lon), axis=1)

        wh1_df = base[base["D1"] <= base["D2"]]
        wh2_df = base[base["D1"] > base["D2"]]

        total_orders = wh1_df.TotalOrders.sum() + wh2_df.TotalOrders.sum()
        wh1_riders = max(1, round(total_riders * wh1_df.TotalOrders.sum() / total_orders))
        wh2_riders = total_riders - wh1_riders
    else:
        wh1_df = base
        wh2_df = pd.DataFrame()
        wh1_riders = total_riders
        wh2_riders = 0

    wh1_plan_a = plan_a(wh1_df, capacity_per_rider, wh1_lat, wh1_lon, WH1_NAME)
    wh1_plan_b = plan_b(wh1_df, wh1_riders, wh1_lat, wh1_lon, WH1_NAME)

    st.subheader("üì¶ WH1 Routes")
    st.dataframe(wh1_plan_b)

    st.subheader("üó∫Ô∏è WH1 ‚Äì Route Visual Validation")
    for biker_id in sorted(wh1_plan_b.Biker_ID.unique()):
        st.markdown(f"### üõµ WH1 ‚Äì Biker {biker_id}")
        m = plot_biker_route(
            wh1_plan_b[wh1_plan_b.Biker_ID == biker_id],
            WH1_NAME
        )
        st_folium(m, height=400)

    if enable_wh2:
        wh2_plan_a = plan_a(wh2_df, capacity_per_rider, wh2_lat, wh2_lon, WH2_NAME)
        wh2_plan_b = plan_b(wh2_df, wh2_riders, wh2_lat, wh2_lon, WH2_NAME)

        st.subheader("üì¶ WH2 Routes")
        st.dataframe(wh2_plan_b)

        st.subheader("üó∫Ô∏è WH2 ‚Äì Route Visual Validation")
        for biker_id in sorted(wh2_plan_b.Biker_ID.unique()):
            st.markdown(f"### üõµ WH2 ‚Äì Biker {biker_id}")
            m = plot_biker_route(
                wh2_plan_b[wh2_plan_b.Biker_ID == biker_id],
                WH2_NAME
            )
            st_folium(m, height=400)

    st.subheader("‚¨á Download CSVs")
    st.download_button("WH1 ‚Äì Plan A", wh1_plan_a.to_csv(index=False), "WH1_Plan_A.csv")
    st.download_button("WH1 ‚Äì Plan B", wh1_plan_b.to_csv(index=False), "WH1_Plan_B.csv")

    if enable_wh2:
        st.download_button("WH2 ‚Äì Plan A", wh2_plan_a.to_csv(index=False), "WH2_Plan_A.csv")
        st.download_button("WH2 ‚Äì Plan B", wh2_plan_b.to_csv(index=False), "WH2_Plan_B.csv")

