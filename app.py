# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-Xvp9ny6pf-J5-ByQGZKRlpKEU-48EzD
"""

import streamlit as st
import pandas as pd
import math
import numpy as np
from io import BytesIO

# ==================================================
# PAGE CONFIG
# ==================================================
st.set_page_config(page_title="SKC Chennai Logistics Optimizer", layout="wide")
st.title("SKC-Chennai Biker Model Route Planner")

# ==================================================
# CONFIGURATION & MASTER DATA (With PRIORITY MAPPING)
# ==================================================
# FORMAT: "Pincode": (Latitude, Longitude, Zone, PRIORITY_LEVEL)
# Priority 1 = Do First (West/GST)
# Priority 2 = Do Second (South/Deep)
# Priority 3 = Do Third (East/Medavakkam)
# Priority 4 = Do Last (North/City/OMR)

WH1_LAT, WH1_LON = 12.9326, 80.1454  # Chitlapakkam
WH2_LAT, WH2_LON = 13.0102, 80.2155  # Guindy

PINCODE_MASTER = {
    # =========================================================
    # WH1 ZONES: SOUTH / OMR / TAMBARAM
    # Logic: Sweep West (GST) -> South -> East (Medavakkam) -> North (City)
    # =========================================================

    # --- PRIORITY 1: The "GST Road" West/Central Cluster ---
    "600064": (12.9320, 80.1450, "South / OMR / Tambaram", 1), # Chitlapakkam (Start)
    "600044": (12.9500, 80.1400, "South / OMR / Tambaram", 1), # Chromepet
    "600045": (12.9240, 80.1150, "South / OMR / Tambaram", 1), # Tambaram West
    "600059": (12.9250, 80.1250, "South / OMR / Tambaram", 1), # Tambaram East
    "600046": (12.9050, 80.1220, "South / OMR / Tambaram", 1), # Tambaram IAF
    "600047": (12.9400, 80.1150, "South / OMR / Tambaram", 1), # Pammal
    "600070": (12.9700, 80.1300, "South / OMR / Tambaram", 1), # Anakaputhur
    "600075": (12.9720, 80.1450, "South / OMR / Tambaram", 1), # Pammal
    "600043": (12.9550, 80.1450, "South / OMR / Tambaram", 1), # Pallavaram

    # --- PRIORITY 2: The "Deep South" Cluster ---
    "600063": (12.9045, 80.0886, "South / OMR / Tambaram", 2), # Perungalathur
    "600048": (12.8900, 80.0800, "South / OMR / Tambaram", 2), # Vandalur

    # --- PRIORITY 3: The "East Link" (Camp Road / Medavakkam) ---
    "600073": (12.8750, 80.1650, "South / OMR / Tambaram", 3), # Selaiyur
    "600126": (12.8950, 80.1600, "South / OMR / Tambaram", 3), # Madambakkam
    "600100": (12.9200, 80.1800, "South / OMR / Tambaram", 3), # Medavakkam
    "600117": (12.9600, 80.1770, "South / OMR / Tambaram", 3), # Keelkattalai

    # --- PRIORITY 4: OMR / ECR / City South ---
    "600119": (12.9000, 80.2270, "South / OMR / Tambaram", 4), # Sholinganallur
    "600097": (12.9450, 80.2300, "South / OMR / Tambaram", 4), # Thoraipakkam
    "600096": (12.9650, 80.2450, "South / OMR / Tambaram", 4), # Perungudi
    "600041": (12.9860, 80.2600, "South / OMR / Tambaram", 4), # Thiruvanmiyur
    "600020": (13.0060, 80.2570, "South / OMR / Tambaram", 4), # Adyar
    "600090": (12.9980, 80.2600, "South / OMR / Tambaram", 4), # Besant Nagar
    "600115": (12.9880, 80.2430, "South / OMR / Tambaram", 4), # Taramani
    "600105": (13.0650, 80.2650, "South / OMR / Tambaram", 4), # Adyar Outskirts

    # =========================================================
    # WH2 ZONES: GUINDY / CENTRAL / NORTH
    # Logic: Guindy -> Velachery -> Central -> North
    # =========================================================

    # --- PRIORITY 1: Immediate Guindy Area ---
    "600032": (13.0102, 80.2155, "Velachery / Guindy / Saidapet", 1), # Guindy
    "600016": (13.0055, 80.1983, "Velachery / Guindy / Saidapet", 1), # St Thomas Mount
    "600015": (13.0150, 80.2300, "Velachery / Guindy / Saidapet", 1), # Saidapet
    "600022": (13.0012, 80.2270, "Velachery / Guindy / Saidapet", 1), # Little Mount

    # --- PRIORITY 2: Velachery / Madipakkam ---
    "600042": (12.9780, 80.2200, "Velachery / Guindy / Saidapet", 2), # Velachery
    "600114": (12.9650, 80.2050, "Velachery / Guindy / Saidapet", 2), # Madipakkam
    "600091": (12.9680, 80.1950, "Velachery / Guindy / Saidapet", 2), # Madipakkam South
    "600088": (12.9950, 80.2050, "Velachery / Guindy / Saidapet", 2), # Adambakkam
    "600061": (12.9830, 80.1860, "Velachery / Guindy / Saidapet", 2), # Nanganallur
    "600113": (12.9730, 80.2380, "Velachery / Guindy / Saidapet", 2), # Taramani

    # --- PRIORITY 3: Central Chennai (T. Nagar / West Mambalam) ---
    "600017": (13.0420, 80.2350, "Central Chennai", 3),
    "600033": (13.0370, 80.2230, "West / Inner West", 3),
    "600024": (13.0530, 80.2250, "Central Chennai", 3),
    "600034": (13.0620, 80.2420, "Central Chennai", 3),
    "600094": (13.0587, 80.2212, "Central Chennai", 3),
    "600026": (13.0550, 80.2115, "West / Inner West", 3),
    "600083": (13.0350, 80.2120, "West / Inner West", 3),

    # --- PRIORITY 4: West / Anna Nagar ---
    "600040": (13.0880, 80.2150, "Central Chennai", 4),
    "600102": (13.0890, 80.2218, "Central Chennai", 4),
    "600101": (13.0935, 80.1937, "West / Inner West", 4),
    "600037": (13.0031, 80.1944, "West / Inner West", 4),
    "600106": (13.0720, 80.2120, "West / Inner West", 4),
    "600107": (13.0660, 80.1990, "West / Inner West", 4),

    # --- PRIORITY 5: North Chennai (Default for rest) ---
    "600001": (13.0964, 80.2872, "North Chennai", 5),
    "600003": (13.0880, 80.2760, "North Chennai", 5),
    "600007": (13.0840, 80.2560, "North Chennai", 5),
    "600011": (13.1246, 80.2327, "North Chennai", 5),
    "600012": (13.0970, 80.2580, "North Chennai", 5),
    "600013": (13.1167, 80.2917, "North Chennai", 5),
    "600021": (13.1060, 80.2860, "North Chennai", 5),
    "600023": (13.0975, 80.2306, "Central Chennai", 5),
    "600051": (13.1700, 80.2450, "North Chennai", 5),
    # ... (Any pincode not listed above gets handled by default priority or Zone mapping)
}

# --- Default Fallback for missing Pincodes ---
# If a pincode isn't in the specific list above, we assume Priority 5 (Last)
DEFAULT_PRIORITY = 5

WH1_ZONES = ["South / OMR / Tambaram", "Outer West / Peripheral"]
WH2_ZONES = ["Velachery / Guindy / Saidapet", "Central Chennai", "West / Inner West", "North Chennai"]

# ==================================================
# 1. UTILS
# ==================================================
def haversine(lat1, lon1, lat2, lon2):
    R = 6371.0
    lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2])
    dlat, dlon = lat2 - lat1, lon2 - lon1
    a = math.sin(dlat / 2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2)**2
    return 2 * math.asin(math.sqrt(a)) * R

# ==================================================
# 2. PRIORITY-BASED ROUTING ENGINE
# ==================================================
def route_priority_nearest(df, start_lat, start_lon):
    """
    1. Sorts data by 'Priority' (1 -> 2 -> 3...)
    2. Within each Priority group, uses Nearest Neighbor to sequence the stops.
    """
    if df.empty: return df

    full_route = []
    curr_lat, curr_lon = start_lat, start_lon

    # Process each Priority Level sequentially
    unique_priorities = sorted(df['Priority'].unique())

    for prio in unique_priorities:
        # Get all stops in this priority level
        cluster = df[df['Priority'] == prio].copy()

        # NEAREST NEIGHBOR LOGIC within the cluster
        while not cluster.empty:
            dists = cluster.apply(
                lambda row: haversine(curr_lat, curr_lon, row['Latitude'], row['Longitude']),
                axis=1
            )
            closest_idx = dists.idxmin()
            closest_row = cluster.loc[closest_idx]

            full_route.append(closest_row)
            curr_lat, curr_lon = closest_row['Latitude'], closest_row['Longitude']
            cluster = cluster.drop(closest_idx)

    return pd.DataFrame(full_route)

def get_optimized_sequence(df, start_lat, start_lon):
    # Ensure all rows have a priority (fill missing with 5)
    df['Priority'] = df['Priority'].fillna(5)

    remaining = df.copy()

    # --- HANDLE START POINT ---
    # Lock start point if present
    start_matches = remaining[
        (np.abs(remaining['Latitude'] - start_lat) < 0.005) &
        (np.abs(remaining['Longitude'] - start_lon) < 0.005)
    ]

    pre_sequence = []
    if not start_matches.empty:
        pre_sequence.append(start_matches)
        remaining = remaining.drop(start_matches.index)
        # Update start coordinates
        start_lat = start_matches.iloc[0]['Latitude']
        start_lon = start_matches.iloc[0]['Longitude']

    # Run Priority Routing on the rest
    routed_df = route_priority_nearest(remaining, start_lat, start_lon)

    if pre_sequence:
        return pd.concat(pre_sequence + [routed_df])
    return routed_df

# ==================================================
# GENERATORS
# ==================================================
def generate_plans(data, total_available_staff, max_cap):
    w1_data = data[data.Zone.isin(WH1_ZONES)].copy()
    w2_data = data[~data.Pincode.isin(w1_data.Pincode)].copy()

    seq_w1 = get_optimized_sequence(w1_data, WH1_LAT, WH1_LON)
    seq_w2 = get_optimized_sequence(w2_data, WH2_LAT, WH2_LON)

    # PLAN A Logic
    def plan_a_logic(ordered_df, wh_name, cap, start_id):
        res, biker, load = [], start_id, 0
        if ordered_df.empty: return pd.DataFrame(), start_id
        for _, r in ordered_df.iterrows():
            if load + r.Orders > cap:
                biker += 1
                load = 0
            res.append({**r.to_dict(), "Biker_ID": biker, "Warehouse": wh_name})
            load += r.Orders
        return pd.DataFrame(res), biker

    pa1, last_id_w1 = plan_a_logic(seq_w1, "WH1", max_cap, 1)
    pa2, total_needed_a = plan_a_logic(seq_w2, "WH2", max_cap, last_id_w1 + 1)

    # PLAN B Logic
    w1_b_count = max(1, round(total_available_staff * len(w1_data) / len(data)))
    w2_b_count = max(1, total_available_staff - w1_b_count)

    pb1 = pd.concat([c.assign(Biker_ID=i+1, Warehouse="WH1") for i, c in enumerate(np.array_split(seq_w1, w1_b_count))]) if not seq_w1.empty else pd.DataFrame()
    pb2 = pd.concat([c.assign(Biker_ID=i+1+w1_b_count, Warehouse="WH2") for i, c in enumerate(np.array_split(seq_w2, w2_b_count))]) if not seq_w2.empty else pd.DataFrame()

    return pd.concat([pa1, pa2]), pd.concat([pb1, pb2]), total_needed_a

# ==================================================
# UI / MAIN
# ==================================================
if "results" not in st.session_state:
    st.session_state.results = {}

st.sidebar.header("Operational Constraints")
max_cap_input = st.sidebar.number_input("Max Orders per Biker (Plan A Limit)", 1, 100, 15)
staff_count = st.sidebar.number_input("Total Internal Staff Available", 1, 100, 5)
uploaded_file = st.sidebar.file_uploader("Upload Delivery Data", type=["csv", "xlsx"])

if st.button("Generate Dispatch Sheets") and uploaded_file:
    raw = pd.read_excel(uploaded_file) if uploaded_file.name.endswith("xlsx") else pd.read_csv(uploaded_file)
    raw.columns = [c.strip() for c in raw.columns]
    raw['Pincode'] = raw['Pincode'].astype(str).str.strip()

    # Create Master DataFrame with Priority
    master_rows = []
    for k, v in PINCODE_MASTER.items():
        # Handle format (Lat, Lon, Zone, Priority) or (Lat, Lon, Zone)
        prio = v[3] if len(v) > 3 else 5
        master_rows.append({"Pincode": k, "Latitude": v[0], "Longitude": v[1], "Zone": v[2], "Priority": prio})

    master_df = pd.DataFrame(master_rows)
    merged = raw.groupby('Pincode', as_index=False)['Orders'].sum().merge(master_df, on="Pincode", how="inner")

    plan_a, plan_b, total_needed = generate_plans(merged, staff_count, max_cap_input)
    st.session_state.results = {"A": plan_a, "B": plan_b, "needed": total_needed, "staff": staff_count}

if st.session_state.results:
    needed = st.session_state.results["needed"]
    staff = st.session_state.results["staff"]
    extra = max(0, needed - staff)

    st.markdown("Staffing Summary & Requirements")
    m1, m2, m3 = st.columns(3)
    m1.metric("Bikers Needed (Plan A)", needed)
    m2.metric("Total Staff We Have Now", staff)
    m3.metric("Freelancers Needed", extra, delta=extra if extra > 0 else None, delta_color="inverse")

    if extra > 0:
        st.error(f"Hire {extra} freelancers to stay within the {max_cap_input}-order capacity limit.")
    else:
        st.success("âœ… Current staff is sufficient for the workload.")

    c1, c2 = st.columns(2)
    c1.download_button("Download Plan A (Capacity)", st.session_state.results["A"].to_csv(index=False), "Plan_A_Dispatch.csv")
    c2.download_button("Download Plan B (Split)", st.session_state.results["B"].to_csv(index=False), "Plan_B_Dispatch.csv")

    st.write("Preview: Plan A Route Sequence")
    st.dataframe(st.session_state.results["A"][['Warehouse', 'Biker_ID', 'Pincode', 'Orders', 'Priority', 'Zone']])

